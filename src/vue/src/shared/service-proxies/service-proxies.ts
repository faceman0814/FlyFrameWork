//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class DapperServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined, cancelToken?: CancelToken): Promise<UserApiResponse> {
        let url_ = this.baseUrl + "/api/Dapper/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserApiResponse.fromJS(resultData200);
            return Promise.resolve<UserApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success - No return data
     */
    execute(id: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Dapper/Execute?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute(_response);
        });
    }

    protected processExecute(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success - No return data
     */
    local( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Local";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLocal(_response);
        });
    }

    protected processLocal(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success - No return data
     */
    distributed( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Distributed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDistributed(_response);
        });
    }

    protected processDistributed(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class EventBusServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param testStr (optional) 
     * @return No Content - Method does not return any data
     */
    checkReceivedMessage(testStr: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/EventBus/CheckReceivedMessage?";
        if (testStr === null)
            throw new Error("The parameter 'testStr' cannot be null.");
        else if (testStr !== undefined)
            url_ += "TestStr=" + encodeURIComponent("" + testStr) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckReceivedMessage(_response);
        });
    }

    protected processCheckReceivedMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FileServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * 文件控制器
     * @return Success
     */
    getFile( cancelToken?: CancelToken): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/File/GetFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }
}

export class HangFireServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return No Content - Method does not return any data
     */
    hangFireTest( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/HangFire/HangFireTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHangFireTest(_response);
        });
    }

    protected processHangFireTest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LoginServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginIn(body: LoginDto | undefined, cancelToken?: CancelToken): Promise<UserLoginDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Login/LoginIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoginIn(_response);
        });
    }

    protected processLoginIn(response: AxiosResponse): Promise<UserLoginDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserLoginDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<UserLoginDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserLoginDtoApiResponse>(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | undefined, cancelToken?: CancelToken): Promise<UserLoginDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Login/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<UserLoginDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserLoginDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<UserLoginDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserLoginDtoApiResponse>(null as any);
    }
}

export class MinioServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * 1、判断指定bucket是否存在
     * @return Success - No return data
     */
    isBucketExit( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/IsBucketExit";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsBucketExit(_response);
        });
    }

    protected processIsBucketExit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 2、 创建bucket
     * @return Success - No return data
     */
    createBucket( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/CreateBucket";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBucket(_response);
        });
    }

    protected processCreateBucket(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 3、移除bucket
     * @return Success - No return data
     */
    deleteBucket( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/DeleteBucket";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteBucket(_response);
        });
    }

    protected processDeleteBucket(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 4、获取bucket列表
     * @return Success
     */
    getBucketList( cancelToken?: CancelToken): Promise<ListAllMyBucketsResultApiResponse> {
        let url_ = this.baseUrl + "/api/Minio/GetBucketList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBucketList(_response);
        });
    }

    protected processGetBucketList(response: AxiosResponse): Promise<ListAllMyBucketsResultApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListAllMyBucketsResultApiResponse.fromJS(resultData200);
            return Promise.resolve<ListAllMyBucketsResultApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListAllMyBucketsResultApiResponse>(null as any);
    }

    /**
     * 1、下载 bucket中的文件
     * @param objectName (optional) 文件名
     * @return Success - No return data
     */
    downloadObject(objectName: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/DownloadObject?";
        if (objectName === null)
            throw new Error("The parameter 'objectName' cannot be null.");
        else if (objectName !== undefined)
            url_ += "objectName=" + encodeURIComponent("" + objectName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadObject(_response);
        });
    }

    protected processDownloadObject(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 2、上传 本地指定文件
     * @param fileFullPath (optional) 上传文件的完整绝对路径，例如：D:\test\test.txt
     * @return Success - No return data
     */
    uploadObject(fileFullPath: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/UploadObject?";
        if (fileFullPath === null)
            throw new Error("The parameter 'fileFullPath' cannot be null.");
        else if (fileFullPath !== undefined)
            url_ += "fileFullPath=" + encodeURIComponent("" + fileFullPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadObject(_response);
        });
    }

    protected processUploadObject(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 3、删除 指定桶中的指定文件
     * @param objectName (optional) 文件名
     * @return Success - No return data
     */
    deleteObject(objectName: string | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Minio/DeleteObject?";
        if (objectName === null)
            throw new Error("The parameter 'objectName' cannot be null.");
        else if (objectName !== undefined)
            url_ += "objectName=" + encodeURIComponent("" + objectName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteObject(_response);
        });
    }

    protected processDeleteObject(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 4、获取 指定文件的Url链接 （有效期 7天）
     * @param objectName (optional) 文件名
     * @return Success
     */
    getObjectUrl(objectName: string | undefined, cancelToken?: CancelToken): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Minio/GetObjectUrl?";
        if (objectName === null)
            throw new Error("The parameter 'objectName' cannot be null.");
        else if (objectName !== undefined)
            url_ += "objectName=" + encodeURIComponent("" + objectName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetObjectUrl(_response);
        });
    }

    protected processGetObjectUrl(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }
}

export class RabbitMqServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return No Content - Method does not return any data
     */
    publish( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/RabbitMq/Publish";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content - Method does not return any data
     */
    subscribe( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/RabbitMq/Subscribe";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribe(_response);
        });
    }

    protected processSubscribe(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return No Content - Method does not return any data
     */
    test( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/User/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return Success - No return data
     */
    createUser(body: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/User/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return Success - No return data
     */
    updateUser(body: UserDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Bucket implements IBucket {
    name: string | undefined;
    creationDate: string | undefined;
    readonly creationDateDateTime: moment.Moment;

    constructor(data?: IBucket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.creationDate = _data["CreationDate"];
            (<any>this).creationDateDateTime = _data["CreationDateDateTime"] ? moment(_data["CreationDateDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Bucket {
        data = typeof data === 'object' ? data : {};
        let result = new Bucket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["CreationDate"] = this.creationDate;
        data["CreationDateDateTime"] = this.creationDateDateTime ? this.creationDateDateTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): Bucket {
        const json = this.toJSON();
        let result = new Bucket();
        result.init(json);
        return result;
    }
}

export interface IBucket {
    name: string | undefined;
    creationDate: string | undefined;
    creationDateDateTime: moment.Moment;
}

export class ListAllMyBucketsResult implements IListAllMyBucketsResult {
    owner: string | undefined;
    buckets: Bucket[] | undefined;

    constructor(data?: IListAllMyBucketsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.owner = _data["Owner"];
            if (Array.isArray(_data["Buckets"])) {
                this.buckets = [] as any;
                for (let item of _data["Buckets"])
                    this.buckets.push(Bucket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListAllMyBucketsResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListAllMyBucketsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Owner"] = this.owner;
        if (Array.isArray(this.buckets)) {
            data["Buckets"] = [];
            for (let item of this.buckets)
                data["Buckets"].push(item.toJSON());
        }
        return data;
    }

    clone(): ListAllMyBucketsResult {
        const json = this.toJSON();
        let result = new ListAllMyBucketsResult();
        result.init(json);
        return result;
    }
}

export interface IListAllMyBucketsResult {
    owner: string | undefined;
    buckets: Bucket[] | undefined;
}

export class ListAllMyBucketsResultApiResponse implements IListAllMyBucketsResultApiResponse {
    success: boolean;
    message: string | undefined;
    data: ListAllMyBucketsResult;

    constructor(data?: IListAllMyBucketsResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["Success"];
            this.message = _data["Message"];
            this.data = _data["Data"] ? ListAllMyBucketsResult.fromJS(_data["Data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListAllMyBucketsResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListAllMyBucketsResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Success"] = this.success;
        data["Message"] = this.message;
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): ListAllMyBucketsResultApiResponse {
        const json = this.toJSON();
        let result = new ListAllMyBucketsResultApiResponse();
        result.init(json);
        return result;
    }
}

export interface IListAllMyBucketsResultApiResponse {
    success: boolean;
    message: string | undefined;
    data: ListAllMyBucketsResult;
}

export class LoginDto implements ILoginDto {
    userName: string | undefined;
    password: string | undefined;
    isApiLogin: boolean;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.password = _data["Password"];
            this.isApiLogin = _data["IsApiLogin"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        data["IsApiLogin"] = this.isApiLogin;
        return data;
    }

    clone(): LoginDto {
        const json = this.toJSON();
        let result = new LoginDto();
        result.init(json);
        return result;
    }
}

export interface ILoginDto {
    userName: string | undefined;
    password: string | undefined;
    isApiLogin: boolean;
}

export class StringApiResponse implements IStringApiResponse {
    success: boolean;
    message: string | undefined;
    data: string | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["Success"];
            this.message = _data["Message"];
            this.data = _data["Data"];
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Success"] = this.success;
        data["Message"] = this.message;
        data["Data"] = this.data;
        return data;
    }

    clone(): StringApiResponse {
        const json = this.toJSON();
        let result = new StringApiResponse();
        result.init(json);
        return result;
    }
}

export interface IStringApiResponse {
    success: boolean;
    message: string | undefined;
    data: string | undefined;
}

export class User implements IUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    fullName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: string | undefined;
    deletionTime: moment.Moment | undefined;
    deleterUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserName: string | undefined;
    lastModifierUserId: string | undefined;
    concurrencyToken: string | undefined;
    creationTime: moment.Moment;
    creatorUserName: string | undefined;
    creatorUserId: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.fullName = _data["FullName"];
            this.password = _data["Password"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            this.deleterUserId = _data["DeleterUserId"];
            this.deletionTime = _data["DeletionTime"] ? moment(_data["DeletionTime"].toString()) : <any>undefined;
            this.deleterUserName = _data["DeleterUserName"];
            this.lastModificationTime = _data["LastModificationTime"] ? moment(_data["LastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserName = _data["LastModifierUserName"];
            this.lastModifierUserId = _data["LastModifierUserId"];
            this.concurrencyToken = _data["ConcurrencyToken"];
            this.creationTime = _data["CreationTime"] ? moment(_data["CreationTime"].toString()) : <any>undefined;
            this.creatorUserName = _data["CreatorUserName"];
            this.creatorUserId = _data["CreatorUserId"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["FullName"] = this.fullName;
        data["Password"] = this.password;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        data["DeleterUserId"] = this.deleterUserId;
        data["DeletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["DeleterUserName"] = this.deleterUserName;
        data["LastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["LastModifierUserName"] = this.lastModifierUserName;
        data["LastModifierUserId"] = this.lastModifierUserId;
        data["ConcurrencyToken"] = this.concurrencyToken;
        data["CreationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["CreatorUserName"] = this.creatorUserName;
        data["CreatorUserId"] = this.creatorUserId;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    fullName: string | undefined;
    password: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: string | undefined;
    deletionTime: moment.Moment | undefined;
    deleterUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserName: string | undefined;
    lastModifierUserId: string | undefined;
    concurrencyToken: string | undefined;
    creationTime: moment.Moment;
    creatorUserName: string | undefined;
    creatorUserId: string | undefined;
}

export class UserApiResponse implements IUserApiResponse {
    success: boolean;
    message: string | undefined;
    data: User;

    constructor(data?: IUserApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["Success"];
            this.message = _data["Message"];
            this.data = _data["Data"] ? User.fromJS(_data["Data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Success"] = this.success;
        data["Message"] = this.message;
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserApiResponse {
        const json = this.toJSON();
        let result = new UserApiResponse();
        result.init(json);
        return result;
    }
}

export interface IUserApiResponse {
    success: boolean;
    message: string | undefined;
    data: User;
}

export class UserDto implements IUserDto {
    id: string | undefined;
    concurrencyToken: string | undefined;
    name: string | undefined;
    password: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    userName: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.concurrencyToken = _data["ConcurrencyToken"];
            this.name = _data["Name"];
            this.password = _data["Password"];
            this.email = _data["Email"];
            this.fullName = _data["FullName"];
            this.userName = _data["UserName"];
            this.phoneNumber = _data["PhoneNumber"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ConcurrencyToken"] = this.concurrencyToken;
        data["Name"] = this.name;
        data["Password"] = this.password;
        data["Email"] = this.email;
        data["FullName"] = this.fullName;
        data["UserName"] = this.userName;
        data["PhoneNumber"] = this.phoneNumber;
        data["IsActive"] = this.isActive;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: string | undefined;
    concurrencyToken: string | undefined;
    name: string | undefined;
    password: string | undefined;
    email: string | undefined;
    fullName: string | undefined;
    userName: string | undefined;
    phoneNumber: string | undefined;
    isActive: boolean;
}

export class UserLoginDto implements IUserLoginDto {
    avatar: string | undefined;
    userName: string | undefined;
    nickName: string | undefined;
    roles: string[] | undefined;
    permissions: string[] | undefined;
    accessToken: string | undefined;
    refreshToken: string | undefined;
    expires: moment.Moment;

    constructor(data?: IUserLoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.avatar = _data["Avatar"];
            this.userName = _data["UserName"];
            this.nickName = _data["NickName"];
            if (Array.isArray(_data["Roles"])) {
                this.roles = [] as any;
                for (let item of _data["Roles"])
                    this.roles.push(item);
            }
            if (Array.isArray(_data["Permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["Permissions"])
                    this.permissions.push(item);
            }
            this.accessToken = _data["AccessToken"];
            this.refreshToken = _data["RefreshToken"];
            this.expires = _data["Expires"] ? moment(_data["Expires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Avatar"] = this.avatar;
        data["UserName"] = this.userName;
        data["NickName"] = this.nickName;
        if (Array.isArray(this.roles)) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["Permissions"] = [];
            for (let item of this.permissions)
                data["Permissions"].push(item);
        }
        data["AccessToken"] = this.accessToken;
        data["RefreshToken"] = this.refreshToken;
        data["Expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserLoginDto {
        const json = this.toJSON();
        let result = new UserLoginDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDto {
    avatar: string | undefined;
    userName: string | undefined;
    nickName: string | undefined;
    roles: string[] | undefined;
    permissions: string[] | undefined;
    accessToken: string | undefined;
    refreshToken: string | undefined;
    expires: moment.Moment;
}

export class UserLoginDtoApiResponse implements IUserLoginDtoApiResponse {
    success: boolean;
    message: string | undefined;
    data: UserLoginDto;

    constructor(data?: IUserLoginDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["Success"];
            this.message = _data["Message"];
            this.data = _data["Data"] ? UserLoginDto.fromJS(_data["Data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Success"] = this.success;
        data["Message"] = this.message;
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): UserLoginDtoApiResponse {
        const json = this.toJSON();
        let result = new UserLoginDtoApiResponse();
        result.init(json);
        return result;
    }
}

export interface IUserLoginDtoApiResponse {
    success: boolean;
    message: string | undefined;
    data: UserLoginDto;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
